/*
 * ReaXtrobe - An Open-Source Pitch-Reactive Addressable RGB LED Controller
 * This code has been heavily modified and re-organized from some code
 * Pete Reiter made, "Spectrum analyzer". That code was itself taken
 * from an Adafruit sketch for the PICCOLO. I have added much scaling,
 * tweaking, smoothing, etc to make this a good stationary music and
 * sound reactive decoration.
 * 
 * Software needed:
 * - FHT library (working version included in "libraries")
 * - Adafruit Neopixel library (available through the Library Manager)
 * 
 * Hardware needed:
 * - Arduino Nano
 * - MAX9814 microphone module, OUT to A0
 * - 2x WS2812 circuar 16 led rings chained together, data on pin 2
 * - A 5V power supply with a bit of power capability, maybe >500mA
 */

////INCLUDES////
#include <avr/pgmspace.h>
#define FHT_N 256
#define LIN_OUT 1
#include <FHT.h>
#include <Adafruit_NeoPixel.h>

/****BEGIN USER EDITABLE SECTION****/

////HARDWARE DEFINES////
#define LED_PIN 2 // digital pin for programming neopixels, default = 2
#define GAIN_PIN 3 // tristate pin for setting the gain, default = 3
#define NUM_PIXELS 32 // number of lights, default = 32 (2x16)

////ROTATION DEFINES////
#define OFFSET_1 0 // rotation offset on first neopixel ring
#define OFFSET_2 8 // rotation offset on second neopixel ring

////AUDIO DEFINES////
#define GAIN 50 // The maximum mic gain for AGC, can be 40dB, 50dB, or 60dB, default = 50

////BEHAVIOR DEFINES////
#define SPACING_FACTOR 8.0 //Used to make bass larger.
#define GAIN_FACTOR 3 //higher means lower output values, a >> operation
#define OFF_THRESH 0 //higher clips lower amplitudes more
#define DECAY 50 //temporal decay. 0-255, lower is slower changing
#define IGNORE_TOP_BINS 50 //how many upper bins to ignore, higher = lower cuttoff = more bass

/****END USER EDITABLE SECTION****/

////ADJUSTMENT MATRICIES////
static const uint8_t PROGMEM
  // This is low-level noise that's subtracted from each FHT output column
  // This was experimentally determined in a quiet room.
  noise[128]={ 
    50, 12, 10, 8, 7, 6, 6, 5, // 0
    5, 5, 4, 4, 4, 4, 4, 4,    // 8
    4, 4, 4, 4, 4, 4, 4, 4,    // 16
    4, 4, 4, 4, 4, 4, 4, 4,    // 24
    4, 4, 4, 4, 4, 4, 4, 4,    // 32
    3, 3, 3, 4, 3, 3, 3, 3,    // 40
    3, 3, 3, 3, 3, 3, 3, 3,    // 48    
    3, 3, 3, 3, 3, 3, 3, 3,    // 56
    3, 3, 3, 3, 3, 3, 3, 3,    // 64
    3, 3, 3, 3, 3, 3, 3, 3,    // 72
    3, 3, 3, 3, 3, 3, 3, 3,    // 80
    3, 3, 3, 3, 3, 3, 3, 3,    // 88
    3, 3, 3, 3, 3, 3, 3, 3,    // 96
    3, 3, 3, 3, 3, 3, 3, 3,    // 104
    3, 3, 3, 3, 3, 3, 3, 3,    // 112
    3, 3, 3, 3, 3, 3, 3, 3     // 120
};
static const uint8_t PROGMEM
  calibration[128] = {
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    1, 1, 1, 1, 1, 1, 1, 1, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2, 
    2, 2, 2, 2, 2, 2, 2, 2,
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3,  
    3, 3, 3, 3, 3, 3, 3, 3  
  } ;
  // This is the mapping from the values in the buckets to the colors
  //representing those values. These numbers were generated by some C
  //code that I've pasted into the bottom of this
  // file. The colors go from off->blue->green->red with an increase in
  //intensity as the values increase. There's also a log10 based
  //response curve figured in.
  #define NUM_COLORS 256
  static const uint32_t PROGMEM colors[NUM_COLORS] = { 
    0x0, 0x17, 0x2b, 0x3d, 0x4d, 0x5c, 0x55f, 0xc5c, 0x1458,
    0x1b55, 0x2252, 0x294f, 0x2f4c, 0x3648, 0x3c45, 0x4242,
    0x473f, 0x4d3b, 0x5238, 0x5735, 0x5d32, 0x612f, 0x662c,
    0x6b29, 0x7026, 0x7424, 0x7821, 0x7c1e, 0x811b, 0x8518,
    0x8916, 0x8d13, 0x9111, 0x950e, 0x980c, 0x9c09, 0xa007,
    0xa305, 0xa702, 0xaa00, 0xacac00, 0xadab00, 0xaeaa00,
    0xafa800, 0xb0a700, 0xb1a500, 0xb2a400, 0xb3a300,0xb4a200,
    0xb5a100, 0xb6a000, 0xb79e00, 0xb89e00, 0xb89c00, 0xb99b00,
    0xba9a00, 0xbb9900, 0xbc9700, 0xbc9700, 0xbd9600, 0xbe9400,
    0xbe9300, 0xbf9200, 0xc09100, 0xc19000, 0xc18f00, 0xc28d00,
    0xc38c00, 0xc38b00, 0xc48a00, 0xc58900, 0xc58900, 0xc68800,
    0xc68600, 0xc78500, 0xc88400, 0xc88300, 0xc98200, 0xc98100,
    0xca8000, 0xca7f00, 0xcb7e00, 0xcc7d00, 0xcc7c00, 0xcd7b00,
    0xcd7a00, 0xce7900, 0xce7800, 0xcf7700, 0xcf7600, 0xd07500,
    0xd07400, 0xd17300, 0xd17300, 0xd27100, 0xd27100, 0xd36f00,
    0xd36f00, 0xd36e00, 0xd46d00, 0xd46c00, 0xd56b00, 0xd56a00,
    0xd66900, 0xd66800, 0xd76700, 0xd76700, 0xd76600, 0xd86400,
    0xd86400, 0xd96300, 0xd96200, 0xd96100, 0xda6000, 0xda6000,
    0xdb5f00, 0xdb5e00, 0xdb5d00, 0xdc5c00, 0xdc5b00, 0xdc5a00,
    0xdd5a00, 0xdd5900, 0xde5800, 0xde5700, 0xde5600, 0xdf5500,
    0xdf5500, 0xdf5400, 0xe05300, 0xe05200, 0xe05200, 0xe15100,
    0xe15000, 0xe14f00, 0xe24e00, 0xe24e00, 0xe24d00, 0xe34c00,
    0xe34b00, 0xe34b00, 0xe44a00, 0xe44900, 0xe44800, 0xe54700, 
    0xe54700, 0xe54600, 0xe64500, 0xe64400, 0xe64300, 0xe74300,
    0xe74200, 0xe74200, 0xe74100, 0xe84000, 0xe83f00, 0xe83e00,
    0xe93e00, 0xe93d00, 0xe93c00, 0xe93b00, 0xea3b00, 0xea3a00,
    0xea3900, 0xeb3900, 0xeb3800, 0xeb3700, 0xeb3700, 0xec3600,
    0xec3500, 0xec3400, 0xec3400, 0xed3400, 0xed3300, 0xed3200,
    0xed3100, 0xee3000, 0xee3000, 0xee2f00, 0xee2e00, 0xef2d00,
    0xef2e00, 0xef2d00, 0xef2c00, 0xf02b00, 0xf02b00, 0xf02a00,
    0xf02900, 0xf12800, 0xf12800, 0xf12700, 0xf12600, 0xf22500,
    0xf22600, 0xf22500, 0xf22400, 0xf32400, 0xf32300, 0xf32200,
    0xf32200, 0xf32100, 0xf42000, 0xf42000, 0xf41f00, 0xf41e00,
    0xf51d00, 0xf51d00, 0xf51c00, 0xf51b00, 0xf51b00, 0xf61b00,
    0xf61b00, 0xf61a00, 0xf61900, 0xf71900, 0xf71800, 0xf71700,
    0xf71700, 0xf71600, 0xf81500, 0xf81500, 0xf81400, 0xf81400,
    0xf81300, 0xf91200, 0xf91200, 0xf91100, 0xf91000, 0xf91000,
    0xfa0f00, 0xfa0f00, 0xfa0e00, 0xfa0d00, 0xfa0d00, 0xfb0c00,
    0xfb0c00, 0xfb0b00, 0xfb0b00, 0xfb0a00, 0xfc0900, 0xfc0900,
    0xfc0800, 0xfc0800, 0xfc0700, 0xfc0700, 0xfd0600, 0xfd0500,
    0xfd0500, 0xfd0400, 0xfd0400, 0xfe0300, 0xfe0300, 0xfe0200,
    0xfe0200, 0xfe0100, 0xff0100
    }; 

////MISC DECLARATION////
Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_PIXELS, LED_PIN, NEO_GRB + NEO_KHZ800);
int num_bins = (FHT_N/2) - 2 - IGNORE_TOP_BINS;
int bins_per_group[NUM_PIXELS / 2];
int avg_val[NUM_PIXELS / 2];
int pos;
volatile uint32_t samplePos = 0;     // Buffer position counter

////SETUP////
void setup() {
  Serial.begin(9600); //IDK why but it won't work unless I do this
  
  memset(avg_val,0,sizeof(avg_val)); //set all to 0, the cheeky way ;)
  
  //calc number of bins for each group
  float weights[NUM_PIXELS / 2];
  for(int g = 0; g < NUM_PIXELS / 2; g++)
  {
    //calc bins per group weight
    weights[g] = pow((float)g, SPACING_FACTOR) + 1;
  }
  float weight_sum = 0;
  for(int g = 0; g < NUM_PIXELS / 2; g++)
  {
    weight_sum += weights[g];
  }
  for(int g = 0; g < NUM_PIXELS / 2; g++)
  {
    float percent = weights[g] / weight_sum;
    float bins = (float)num_bins * percent;
    bins = round(bins);
    if((int)bins > 0)
    {
      bins_per_group[g] = (int)bins;
    }
    else
    {
      bins_per_group[g] = 1;
    }
  }
  
  // FHT setup (may be Nano specific?)
  TIMSK0 = 0; // turn off timer0 for lower jitter
  ADCSRA = 0xe5; // set the adc to free running mode
  ADMUX = 0x40; // use adc0
  DIDR0 = 0x01; // turn off the digital input for adc0

  // Neopixels setup
  // Initialize all pixels to 'off'
  strip.setBrightness(255);
  strip.begin(); // Initialize all pixels to 'off'
  cli();         // disable interrupts when writing neopixels   
  strip.show();
  sei();         // Enable interrupts

  // Set MAX9814 maximum gain
  switch(GAIN)
  {
    case 40: // set to 40dB
      // set pin to high
      pinMode(GAIN_PIN, OUTPUT);
      digitalWrite(GAIN_PIN, HIGH);
      break;
    case 60: // set to 60dB
      // set pin to floating
      digitalWrite(GAIN_PIN, LOW);
      pinMode(GAIN_PIN, INPUT);
      break;
    default: // set to 50dB
    // set pin to low
      pinMode(GAIN_PIN, OUTPUT);
      digitalWrite(GAIN_PIN, LOW);
  }
}

////LOOP////
void loop() {
  uint16_t  x, L;
  while(ADCSRA & _BV(ADIE)); // Wait for audio sampling to finish

  fht_window();
  fht_reorder();
  fht_run();
  fht_mag_lin();
  samplePos = 0;                   // Reset sample counter
  ADCSRA |= _BV(ADIE);             // Resume sampling interrupt

  // Remove noise
  for(x=0; x<FHT_N/2; x++) {
    L = (pgm_read_byte(&noise[x]) << 6);
    fht_lin_out[x] = (fht_lin_out[x] <= L) ? 0 : (fht_lin_out[x] - L);
  }
  
  int bin = 0;
  for (int i = 0; i < NUM_PIXELS / 2; i++)
  {
      int value = 0;
      int curr_val;
      for (int j = 0; j < bins_per_group[i]; j++)
      {
        curr_val = fht_lin_out[bin + 2];
        if(value < curr_val) {
          value = curr_val;
        }
        if(bin + 2 < num_bins)
        {
          bin ++;
        }
      }
      
      value >>= GAIN_FACTOR;
      if (value < OFF_THRESH)
        value = 0;
      if (value >= NUM_COLORS)
        value = NUM_COLORS - 1;  

      if(value > avg_val[i]) {
        avg_val[i] = value;
      }
      else {
        avg_val[i] -= DECAY;
      }
      if(avg_val[i] < 0) {
        avg_val[i] = 0;
      }
  }

  //I would have saved time by doing this in the loop above, but one of
  //the setPixelColor commands was ignored if done out-of-order like
  //below. Bah, the framerate is fine anyway.
  for(int i = 0; i < NUM_PIXELS; i++) {
    if(i >= NUM_PIXELS / 2) {
      
      pos = ((NUM_PIXELS / 2) - 1) - ((i + OFFSET_1) % (NUM_PIXELS/2));
    }
    else {
      pos = (i + OFFSET_2) % (NUM_PIXELS/2);
    }
    strip.setPixelColor(i, pgm_read_dword(&colors[avg_val[pos]]));
  }
  
  cli();        // no interrupts while writing the neopixels
  strip.show();
  sei();        // restore interrupts
}

// interrupt service routine. This gets called each time the ADC finishes 1 sample.
ISR(ADC_vect) { // Audio-sampling interrupt
  // shift the unsigned input to be centered around 0. The 10-bit ADC is 
  // capable of producing values from 0 - 1023, but with a microphone that outputs
  // 2V max and a reference voltage of 3.3V we will never hit the max.
  fht_input[samplePos] = (ADC - 512) << 6;
//  Serial.println(fht_input[samplePos]);
  if(++samplePos >= FHT_N) ADCSRA &= ~_BV(ADIE); // Buffer full, interrupt off
}

/*
// Some C code I used to generate the values->colors map. I didn't run this code on the Arduino. I used ideone.com
// and then pasted the output into my arduino code.
#include <iostream>
#include <stdint.h>
#include <math.h>
using namespace std;
  
const int numValues = 256; // number of colors in our output array. This should correspond 
                          // to the max value you want to display.

double breakPoint = log10(numValues)/3.0;
//double breakPoint = numValues/4.0;
//
// Blend two colors together based on the ratio. ratio of 0.0 will be 100% color a and
// ratio of 1.0 will be 100% color b.
uint32_t blend (uint32_t ina, uint32_t inb, double ratio)
{
  int r = (((ina >> 16) & 0xff) * (1.0-ratio)) + (((inb >> 16) & 0xff) * ratio);
  int g = (((ina >> 8) & 0xff) * (1.0-ratio)) + (((inb >> 8) & 0xff) * ratio);
  int b = (((ina >> 0) & 0xff) * (1.0-ratio)) + (((inb >> 0) & 0xff) * ratio);
  return ((r << 16) | (g << 8) | b);
}
//
// Scale the intensity of the passed in color. I am using max brightness colors and 
// 0.0 - 1.0 as the scale value.
uint32_t scale (uint32_t ina, double scale_value)
{
  int r = ((ina >> 16) & 0xff) * scale_value;
  int g = ((ina >> 8) & 0xff) * scale_value;
  int b = ((ina >> 0) & 0xff) * scale_value;
  return ((r << 16) | (g << 8) | b);  
}
//  
// Fade off -> blue -> green -> red. I've built in a logarithmic response to make it more of a
// dB meter.
int main() { 
  for (int i = 1; i <= numValues; i++)
  {
    double logValue = log10(i);
    double scaleValue = log10(i+2) / log10(numValues+2);
    //double logValue = i;
    //double scaleValue = i+2 / numValues+2;
    double ratio = (logValue < breakPoint) ? logValue / breakPoint : (logValue - breakPoint) / breakPoint;
    uint32_t color = 0;
    if (logValue < breakPoint)
      color = blend (0x000000, 0x00ff, ratio);
    else if (logValue < breakPoint * 2)
      color = blend (0x0000ff, 0x00ff00, ratio);
    else
      color = blend (0x00ff00, 0xff0000, ratio);
    color = scale (color, scaleValue);
    cout <<  "0x" << hex << color << ", ";
  }
  return 0; 
}
*/
